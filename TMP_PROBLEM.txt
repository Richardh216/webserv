I'm having a complex problem that I'm trying to understand, I'm not sure if I have a problem in the first place, but if I do, I'm not sure that the current way to go about fixing it is the best

So:

I have this in my project requirements:

Your server must never block and the client can be bounced properly if necessary.
• It must be non-blocking and use only 1 poll() (or equivalent) for all the I/O
operations between the client and the server (listen included).
• poll() (or equivalent) must check read and write at the same time.
• You must never do a read or a write operation without going through poll() (or
equivalent).
• Checking the value of errno is strictly forbidden after a read or a write operation
Because you have to use non-blocking file descriptors, it is
possible to use read/recv or write/send functions with no poll()
(or equivalent), and your server wouldn’t be blocking.
But it would consume more system resources.
Thus, if you try to read/recv or write/send in any file descriptor
without using poll() (or equivalent), your grade will be 0.

I think right now my code calls recv() sometimes when it doesn't find any more data, and immediately flags it as an error if recv() returns -1, which might just be waiting for more data from the client, so it shouldn't be considered invalid immediately right?

My current implementation:
server_sockets.initSockets(parser.servers);
		poller.initPoll(server_sockets.server_fds);

		int curr_nfds;
		for (;;) {
			curr_nfds = poller.nfds;
			poller.processPoll(curr_nfds);

			// check which fds in poll_fds are ready
			for (int i = 0; i < curr_nfds; ++i) {

				bool is_server = connection.isServerFd(poller.poll_fds[i].fd,
					server_sockets.server_fds);

				if (poller.skipFd(is_server, i, curr_nfds)) continue;

				if (is_server) {
					connection.handleServerFd(poller.poll_fds[i].fd, poller);
				}
				else {
					Response response;
					HttpRequest request = parseHttpRequest(poller.poll_fds[i].fd, parser.servers); 
					if (request.isValid) {
						printRequest(request);
						response.chooseServer(poller.poll_fds[i].fd, request, parser.servers);
						response.formResponse(request, webserv);
						response.sendResponse(poller.poll_fds[i].fd);
					}
					poller.removeFd(i, curr_nfds);
				}
			}
			poller.compressFdArr();

this is my main loop, the HTTP request parser only gets called if the socket is already ready for reading, however, it doesn't bounce between clients. it always handles one, and sometimes might throw errors prematurely I think, here is my parsing implementation:

HttpRequest	parseHttpRequest(int clientFd, std::vector<serverConfig>& servers) { //add pending reqeusts vector
	std::string			rawRequest;
	ssize_t				bytesRead;
	HttpRequest			request;
	bool				headersRead = false; //move to struct
	size_t	headerEnd;
	// size_t	delimLen; //may be worth implementing universal delim len
	
	if (request.poll_fd.fd) //if not in pedning requests just assign it
	request.poll_fd.fd = clientFd; //search for it
	char c;

	//Reading request data
	while (!headersRead) {
		bytesRead = recv(clientFd, &c, 1, 0); // Read 1 byte at a time
		if (bytesRead < 0) {
			request.isValid = false;
			request.errorCodes[400] = "Bad Request"; //not necessarily bad
			return request; //return it with whatever was read so far, plus time it was returned
		} else if (bytesRead == 0) {
			break; //the client closed the connection
		}
		rawRequest += c; //append the data
		headerEnd = rawRequest.find("\r\n\r\n");
		if (headerEnd == std::string::npos) {
			headerEnd = rawRequest.find("\n\n"); // Support '\n' only requests
		}
		if (headerEnd != std::string::npos) {
			headersRead = true; // just read, not parsed
		}
	}

	// if no data was read, return invalid request
	if (rawRequest.empty()) {
		request.isValid = false;
		request.errorCodes[400] = "Bad Request";
		return request;
	}

	//start parsing from rawReqeust
	std::istringstream	stream(rawRequest);
	std::string			line;

	// Read and parse the request line
	if (!std::getline(stream, line) || line.empty()) {
		request.isValid = false;
		request.errorCodes[400] = "Bad Request";
		return request;
	}

	// Remove trailing '\r' if it exists
	if (!line.empty() && line.back() == '\r') {
		line.pop_back();
	}

	std::istringstream	lineStream(line); //split the request line into method, path ...
	if (!(lineStream >> request.method >> request.path >> request.httpVersion)) {
		request.isValid = false;
		request.errorCodes[400] = "Bad Request";
		return request;
	}

	//check http method
	static const std::set<std::string>	validMethods = {"GET", "POST", "DELETE"}; //only these methods are allowed
	if (validMethods.find(request.method) == validMethods.end()) {
		request.isValid = false;
		request.errorCodes[405] = "Method Not Allowed";
		return request;
	}

	//check http version						//R: define a string without having to escape special characters like backslashes.
	if (!std::regex_match(request.httpVersion, std::regex(R"(HTTP\/\d\.\d)"))) { //matches strings that start with "HTTP/", then a digit, a dot, and another digit
		request.isValid = false;
		request.errorCodes[505] = "HTTP Version Not Supported";
		return request;
	}

	//read headers
	while (std::getline(stream, line)) { //line != "" makes just \n work
		if (!line.empty() && line.back() == '\r') { //remove \r if present
			line.pop_back();
		}
		if (line.empty()) {  // Stop when an actual empty line is found
			break;
		}

		size_t	colonPos = line.find(':'); //Finds the ":" separator in each header
		if (colonPos == std::string::npos) {
			request.isValid = false;
			request.errorCodes[400] = "Bad Request";
			return request;
		}

		// Extract header key and value
		std::string	key = line.substr(0, colonPos);
		std::string	val = line.substr(colonPos + 1);

		//trim whitespaces
		key.erase(0, key.find_first_not_of(" \t")); //trim leading whitespaces
		key.erase(key.find_last_not_of(" \t") + 1); // trim trailing whitespaces
		val.erase(0, val.find_first_not_of(" \t"));
		val.erase(val.find_last_not_of(" \t") + 1);

		//this ugly bit of code makes first letters capitalized, while keeping everything else lowercase
		key[0] = std::toupper(key[0]);
		size_t j = 0;
		for (size_t i = 1; i < key.size() - 1; i++) {
			if (key[i] == '-' && i + 1 < key.size()) {
					key[i + 1] = std::toupper(key[i + 1]);
					j = i + 1;
			} else if (j != i) {
				key[i] = std::tolower(key[i]);
			}
		}
		//handle the last character
		if (key.size() > 1 && j != key.size() - 1) {
			key[key.size() - 1] = std::tolower(key[key.size() - 1]);
		}

		request.headers[key] = val;
	}

	// Check for Content-Length and Chunked Encoding
	bool	hasContentLength = request.headers.find("Content-Length") != request.headers.end();
	bool	hasChunkedEncoding = request.headers.find("Transfer-Encoding") != request.headers.end() && 
								request.headers["Transfer-Encoding"] == "chunked";

	if (hasContentLength && hasChunkedEncoding) {
		request.isValid = false;
		request.errorCodes[400] = "Bad Request";
		return request;
	}

	//handle case where there is a body, but no content-length, or chunked-transfer-encoding
	//headerEnd - will be useful

	//headers parsed
	request.headersParsed = true;

	std::string	hostValue;
	auto it = request.headers.find("Host");
	if (it != request.headers.end()) {
		hostValue = it->second;
	} else { //missing host header
		request.errorCodes[400] = "Bad Request";
	}

	//get Config data
	size_t			BUFFER_SIZE; //maybe add a check if it's beyond a reasonable amount limit it, so that it won't slow everything down
	const size_t	DEFAULT_MAX_BODY_SIZE = 1048576; // 1MB default
	serverConfig	currentServer = selectServer(request.poll_fd.fd, servers, hostValue);

	if (currentServer.client_max_body_size == 0 && (hasContentLength || hasChunkedEncoding)) {
			request.isValid = false;
			request.errorCodes[413] = "Content Too Large";
			return request;
	} else if (currentServer.client_max_body_size == -1) {
		BUFFER_SIZE = DEFAULT_MAX_BODY_SIZE;
	} else {
		BUFFER_SIZE = currentServer.client_max_body_size;
	}
	std::cout << "BUFFER_SIZE: " << BUFFER_SIZE << std::endl;
	std::vector<char>	buffer(BUFFER_SIZE);

	// Handle request body
	if (hasContentLength) {
		size_t contentLen = 0;
		try {
			contentLen = std::stoull(request.headers.at("Content-Length"));
			if (contentLen == 0) {
				request.isValid = false;
				request.errorCodes[400] = "Bad Request";
				return request;
			}
			if (contentLen > BUFFER_SIZE) { //check if contentLen can fit in BUFFER_SIZE
				request.isValid = false;
				request.errorCodes[413] = "Content Too Large";
				return request;
			}
		} catch (const std::invalid_argument& e) {
			request.isValid = false;
			request.errorCodes[400] = "Bad Request";
			return request;
		} catch (const std::out_of_range& e) {
			request.isValid = false;
			request.errorCodes[400] = "Bad Request";
			return request;
		}

		size_t	bodyStart = rawRequest.find("\r\n\r\n"); //start of body
		if (bodyStart == std::string::npos) {
			bodyStart = rawRequest.find("\n\n");
		}
		if (bodyStart != std::string::npos) {
			bodyStart += (rawRequest[bodyStart] == '\r') ? 4 : 2; //adjust offset
		} else {
			request.isValid = false;
			request.errorCodes[400] = "Bad Request";
			return request;
		}

		 // If the entire body wasn't already received with the headers, continue reading from the socket.
		while (rawRequest.size() < bodyStart + contentLen) {
			bytesRead = recv(clientFd, buffer.data(), BUFFER_SIZE, 0);
			if (bytesRead <= 0) {
				request.isValid = false;
				request.errorCodes[400] = "Bad Request";
				return request;
			}
			rawRequest.append(buffer.data(), bytesRead);
		}
		request.body = rawRequest.substr(bodyStart, contentLen); //Extracts the body from rawRequest
	}

	// Handle chunked transfer encoding
	else if (hasChunkedEncoding) {
		std::string	chunkedBody;
		size_t	pos = rawRequest.find("\r\n\r\n"); //find where body begins
		if (pos == std::string::npos) {
			pos = rawRequest.find("\n\n"); //support \n
		}
		if (pos == std::string::npos) {
			request.isValid = false;
			request.errorCodes[400] = "Bad Request";
			return request;
		}
		pos += (rawRequest.compare(pos, 4, "\r\n\r\n") == 0) ? 4 : 2; //skip the header delim

		// Skip any extra CRLFs that may be present after the header delimiter.
		while (pos < rawRequest.size() && (rawRequest.compare(pos, 2, "\r\n") == 0 || rawRequest[pos] == '\n')) {
			pos += (rawRequest.compare(pos, 2, "\r\n") == 0) ? 2 : 1;
		}

		size_t	totalBodySize = 0;

		while (true) { //breaks when 0\r\n is found
			// Find the CRLF that ends the chunk size line.
			size_t	lineEnd = rawRequest.find("\r\n", pos);
			size_t	delimLen = 2;
			if (lineEnd == std::string::npos) {
				lineEnd = rawRequest.find("\n", pos);
				delimLen = 1; // Adjust for single newline
			}

			while (lineEnd == std::string::npos) { //if lineEnd is not found, need more data // mark it as incomplete data
				bytesRead = recv(clientFd, buffer.data(), BUFFER_SIZE, 0);
				if (bytesRead <= 0) {
					request.isValid = false;
					request.errorCodes[400] = "Bad Request";
					return request;
				}
				rawRequest.append(buffer.data(), bytesRead);
				if ((lineEnd = rawRequest.find("\r\n", pos)) != std::string::npos) {
					delimLen = 2;
				} else if ((lineEnd = rawRequest.find("\n", pos)) != std::string::npos) {
					delimLen = 1;
				}
			}

			// Move past any stray newlines before parsing chunk size
			while (pos < rawRequest.size() && (rawRequest.compare(pos, 2, "\r\n") == 0 || rawRequest[pos] == '\n')) {
				pos += (rawRequest.compare(pos, 2, "\r\n") == 0) ? 2 : 1;
			}

			//end of the chunk size line should be after the current position
			if (lineEnd <= pos) {
				request.isValid = false;
				request.errorCodes[400] = "Bad Request";
				return request;
			}

			//Extract the chunk size from rawRequest
			std::string	chunkSizeStr = rawRequest.substr(pos, lineEnd - pos);
			chunkSizeStr.erase(0, chunkSizeStr.find_first_not_of(" \t"));
			chunkSizeStr.erase(chunkSizeStr.find_last_not_of(" \t") + 1);
			
			//Extract the chunk size (in hexadecimal)
			size_t	chunkSize;
			try {
				chunkSize = std::stoul(chunkSizeStr, nullptr, 16); // Convert str to int, with 16 base system
			} catch (const std::exception& e) {
				request.isValid = false;
				request.errorCodes[400] = "Bad Request";
				return request;
			}

			if (chunkSize == 0) { //the last chunk was received, end of the loop
				break;
			}

			if (totalBodySize + chunkSize > BUFFER_SIZE) { //check for client_max_body_size bounds
				request.isValid = false;
				request.errorCodes[413] = "Content Too Large";
				return request;
			}

			size_t chunkDataStart = lineEnd + delimLen; //Move past the chunk size line (and its CRLF)
			// Ensure the entire chunk and its trailing CRLF are available
			while (rawRequest.size() < chunkDataStart + chunkSize + delimLen) { //If rawRequest is too short, call recv() to read more data from the socket
				bytesRead = recv(clientFd, buffer.data(), BUFFER_SIZE, 0);
				if (bytesRead <= 0) {
					request.isValid = false;
					request.errorCodes[400] = "Bad Request";
					return request;
				}
				rawRequest.append(buffer.data(), bytesRead);
			}
			chunkedBody.append(rawRequest.substr(chunkDataStart, chunkSize)); // Append the chunk data to the chunkBody

			//update body size
			totalBodySize += chunkSize;

			//advance pointer past chunked data
			pos = chunkDataStart + chunkSize;

			//advance pointer past delim
			if (pos < rawRequest.size() && rawRequest.compare(pos, 2, "\r\n") == 0) {
				pos += 2;
			} else if (pos < rawRequest.size() && rawRequest[pos] == '\n') {
				pos += 1;
			}
		}
		request.body = chunkedBody; //store full body
	}
	//in case there is a body, but no Content-Length or Chunked Transfer Encoding
	//in case it's GET or DELETE and there is no header to indicate size, it ignores the body
	if (request.method == "POST" && (!hasContentLength && !hasChunkedEncoding)) {
		if (request.httpVersion == "HTTP/1.1") { //may remove this check
			// std::cout << "VERSION 1.1 CASE" << std::endl;
			request.isValid = false;
			request.errorCodes[411] = "Length Required";
			return request;
		}
		// else if (request.httpVersion == "HTTP/1.0") { //potential, different versions behave differently, probably won't implement
		// 	std::cout << "VERSION 1.0 CASE" << std::endl;
		// }
	}
	return request;
}

My idea of solving this problem, so that my server can bounce clients properly, and won't hang, even though it would have been non-blocking, goes like this:

Basically, in my parser I would just return the current state the request is in if it fails to read more data, along with how many bytes it read and where exactly in the request it is, along with the current time for when it was returned, so that this time could be used to check if a timeout happened, then in the main server loop, after calling the parser, I would have a flag called isPending, which would have been set by the parser, if a request has the isPending flag, that means that it was returned with the current state of the request and timestamp, this request would then get added to the vector of requests, let's call it pendingRequests, that would check when an fd is ready for reading again, then it would look for that fd in the vector pendingRequests, if it finds a request that has been matched with that fd, it will call the parser again, and the parser would take that partial request + the pendingRequests vector, so it would't assign the fd again to the wrong request? May be unnecessary?, have multiple checks to identify if it is a new/partial request, then it would try to continue where it left off, making sure it only calls recv() once per call, so as to adhere to the subject and only call recv() once it went through poll(), then if the request is parsed correctly it will get removed, however if it is still incorrect and the client is not trying to send more data, as in the fd is not ready to read more data the client and it's request will time out and it will be considered an invalid request

here are some comments I made on how I could try to implement it in the main loop:



// check which fds in poll_fds are ready
			for (int i = 0; i < curr_nfds; ++i) {

				bool is_server = connection.isServerFd(poller.poll_fds[i].fd,
					server_sockets.server_fds);

				if (poller.skipFd(is_server, i, curr_nfds)) continue;

				if (is_server) {
					connection.handleServerFd(poller.poll_fds[i].fd, poller);
				}
				else {
					Response response;
					/** loop for pending requests, sockets always ready for reading, 
					 * if it matches a socket with a pendig request
					 * then call the parser again with the current state of the request, + the vector of pending lists (may not be needed if the fd it gets caled with is the one we need)
					 * if fd is inside penidng reqeusts, pick up from where it left off
					 * create timeout timer when returning
					 * 
					 * 
					 * 
					 * std::vector<HttpRequest*> pendingRequests;
					 * 
					 * int fd = poller.poll_fds[i].fd; //assume ready for reading, clients wants to send more data
					 * 
					 * find a request with the 'fd' that is now ready to recieve data
					 * 		if there is no such request just treat it as a new request, and call the parser normally to handle the fd that is now ready to read:  
					 			HttpRequest request = parseHttpRequest(poller.poll_fds[i].fd, parser.servers);
					 * 		else, if the list of pendingRequests has the fd that is now ready, send the current data we have a bout the request and call the parser again
					 * 			curr_request = found request
					 * 		else 
					 * 			timeout maybe?
					 * 
					 * 
					 * 		
					 */
					HttpRequest request = parseHttpRequest(poller.poll_fds[i].fd, parser.servers); //now needs parser.servers to work
					// if (request.isPending)// add to vec if pending request
					if (request.isValid) {
						printRequest(request);
						response.chooseServer(poller.poll_fds[i].fd, request, parser.servers);
						response.formResponse(request, webserv);
						response.sendResponse(poller.poll_fds[i].fd);
					}
					poller.removeFd(i, curr_nfds); //remove request from vec of requests too if valid
				}
			}
			poller.compressFdArr();

can you help me think of other simpler ways to implement it, what I need to implement, do I need to implement it? If yes is my approach good, could it work? I yes how should I go about solving it?